# Year2026

### Day1
```typescript
·思考问题记录
1. “同步”与“异步”

线程安全与竞态条件；

生存期管理；

阻塞与响应性；

异常处理的传递；

缓冲区溢出与背压；

上下文切换的开销；

调试与回溯；

/*伪共享：物理内存靠的太近的两个变量在CPU缓存中在同一个Cache Line，也就是从硬件低层的视角看，两个变量在竞争同一块缓存；
而硬件一致性协议如MESI为了保证每个核心看到的内存数据是一致的，在一个核心修改了某个Cache Line时，
另一个核心缓存里对应的Cache Line会被强制标记为失效从而在需要读取时必须重新加载，从而增加耗时。*/
－－“和嵌入式中664协议中的4字节对齐要求是否相关？”
```

### Day2
```typescript
1.C++11－－“智能指针”
传统指针只是一个保存地址的整数；智能指针则是对原始指针的封装，利用RAII(资源获取即初始化)机制：当只能只针对象本身离开作用域或被销毁时，它会自动释放所指向的堆内存。

a.std::unique_ptr(独占所有权)
特点：同一时间只能有一个unique_ptr指向特定的内存。
所有权转移：不能被拷贝，只能通过std::move()转移。
场景：适用于链表节点、树节点或类的成员变量。

b.std::shared_ptr(共享所有权)
特点：多个shared_ptr可以指向同一个对象。内部维护一个引用计数。
销毁时机：只有当最后一个指向该对象的shared_ptr被销毁即计数归零时，内存才会被释放。
场景：多个对象需要共享同一个资源时。

c.std::weak_ptr(弱引用)
特点：指向shared_ptr管理的对象，但不增加引用计数。
场景：专门用于解决shared_ptr的循环引用问题。
```

### Day3
```typescript
/*bug*/
对多字节类型变量取地址时，大端环境下取到的是高位字节地址，小端环境下取到的是低位字节地址。因此用不同类型指针取值时会产生环境差异。
```

### Day4
```typescript
/*git使用*/
git merge main 和 git rebase:
--git merge main--
优点：真实记录完整保留当时开发和合并的时间线，不会修改之前的提交历史。
缺点：提交历史杂乱，有大量的merge branch main into...

--git rebase--
优点：历史干净，没有多余的merge commit。
缺点：篡改历史，实际上删除了旧的提交，创建了内容相同但Commit ID完全不同的提交；冲突处理需要一个一个commit地去处理。

--场景与选择--
本地私有分支：git rebase，保持与主线同步并且保持提交历史整洁
多人共同开发分支：必须git merge，金律：不要在公共分支上rebase!
最后准备合入main：git merge，保持完整的开发链路和合并证据
```

### Block5
```typescript
--2.27--
/*正则表达式*/
字符匹配：
'.'：除换行符外的任意单个字符
'\d'：数字0－9
'\w'：字母、数字、下划线
[abc]：括号内的任意一个字符
^/$：字符串的开头/结尾
[ \t]：空格/制表符
()：匹配到的括号内的内容会被暂存，在替换时用'$1'调用
\r?：匹配可能存在的换行符
$：定位行尾

数量限定符：
'*'：任意次
'+'：>=1次
'?'：0/1次
{m,n}：m到n次

应用：
－“将单行注释符//全部替换为/**/形式”？
－"//[ \t]*(.*?)\r?$"->"/*$1*/"

```